// scale from [0,1] to texture coordinatesuniform vec2 textureScale;uniform vec2 shearXY;//elevation in z to which maximum shear will be applieduniform float shearBaseline;// scale factor to convert max(cols, rows) to 1uniform float scaleGridToUnity;// scale factor to convert the z value stored in zTexture to [0,1]uniform float scaleZToUnity;// offset passed vertex position by this many rowsuniform float rowOffset;// texture containing height valuesuniform sampler2D zTexture;// if true, shading is computed, otherwise only texture mapping is applieduniform bool applyShading;// if true, fog is computeduniform bool applyFog;// vertex position as column/row index of the elevation gridattribute vec2 v_vertex;// pass the position where the texture is sampled to the fragment shadervarying vec3 texCoord;// pass the fog weight to the fragment shadervarying float fog;void main(void){    // vertex position is shifted vertically    // gridPos is in [0..1]    vec2 gridPos = vec2(v_vertex.x, v_vertex.y + rowOffset) * scaleGridToUnity;        // texture coordinates: position to sample height texture and optional texture    texCoord = vec3(gridPos.xy * textureScale, 1.);        // sample elevation from height texture    // the elevation is relativ to the dimensions of the grid    float zGRID = texture2D(zTexture, texCoord.xy).x;        // compose position vector    vec4 v = vec4(gridPos.xy, zGRID * scaleGridToUnity, 1.);        // shearing in XY plane for plan oblique rendering    // ***** uniform shearing *****    v.xy += shearXY * (shearBaseline - abs(v.z - shearBaseline));        // ***** concentric shearing *****    /*    // diameter of "shearing wave". Should be a uniform for animation.    float peakDistance = 0.2;    // width of the "shearing wave". Should be a uniform for animation.    // must be smaller than peakDistance    float waveWidth = peakDistance * 0.3;    // amplitude of the shearing effect at the peak of the wave. Should be a uniform for animation.    float amplitude = 0.2;        // shearXY is the center of the shearing wave in a coordinate system    // with the origin at the center of the terrain model, and an extent of +/-1.    // Scale and offset to bring it to the coordinate system of the vertex.    vec2 center = shearXY * vec2(0.5, -0.5) + vec2(0.5, 0.5);        // distance of current vertex to center of circle    vec2 deltaXY = v.xy - center;    float dist = length(deltaXY);    vec2 dir = deltaXY / dist;        // interpolate shearing effect for current vertex    float t = abs(dist - peakDistance);    float w = 1.0 - smoothstep(0.0, waveWidth, t);    v.xy += dir * w * amplitude * v.z + 0.*shearBaseline;*/        // ***** radial shearing *****    /*vec2 center = vec2(0.5, 0.5);    vec2 deltaXY = v.xy - center;    float dist = length(deltaXY);    vec2 dir = normalize(deltaXY);// / dist;    v.xy += v.z * deltaXY * -shearXY.y + 0.*shearBaseline;    */     gl_Position = gl_ModelViewProjectionMatrix * v;        // the scale factor to apply to height values for 1D texture mapping    texCoord.z = zGRID * scaleZToUnity;    // compute the normal    // sampling distance: 1 cell in texture units    vec2 d = scaleGridToUnity * textureScale;    // the elevation below (relativ to the dimensions of the grid)    float z_dyGRID = (texture2D(zTexture, vec2(texCoord.x, texCoord.y + d.y)).x);    // the elevation to the right (relativ to the dimensions of the grid)    float z_dxGRID = (texture2D(zTexture, vec2(texCoord.x + d.x, texCoord.y)).x);    // normalized normal    vec3 n = normalize(vec3(zGRID - z_dxGRID, zGRID - z_dyGRID, 1.));    n = gl_NormalMatrix * n;        // compute a diffuse color. Final clamping of gl_FrontColor is done by OpenGL.    float nDotVP = max(0.0, dot(n, normalize(vec3(gl_LightSource[0].position))));    vec4 amb = gl_LightSource[0].ambient;    vec4 diff = gl_LightSource[0].diffuse * nDotVP;    gl_FrontColor = gl_FrontLightModelProduct.sceneColor    + amb * gl_FrontMaterial.ambient    + diff * gl_FrontMaterial.diffuse;        if (applyFog) {        // compute linear fog. Could be done in fragment shader as well.        // the distance between the camera and the vertex in eye coordinates        float eyeCoordinateDist = vec4(gl_ModelViewMatrix * v).z;        fog = (gl_Fog.end - abs(eyeCoordinateDist)) * gl_Fog.scale;        // fog must be in [0,1]        fog = clamp(fog, 0.0, 1.0);    } else {        fog = 0.;    }}